desc:PoulpyLoop_v0542
options:maxmem=32000000
options:gmem=PoulpyLoopy

in_pin:Left In
in_pin:Right In
out_pin:Left Out
out_pin:Right Out

slider1:40<0,256,1>Fade (échantillons)
slider2:0.0<-24,24,1>Pitch Control
slider3:0<0,1,1{OFF,ON}>Monitoring à l'arrêt
slider4:0<0,127,1>Mod 1 Start
slider5:0<0,127,1>Mod 2 Start
slider6:0<0,127,1>Mod 3 Start
slider7:0<0,127,1>Mod 4 Start
slider8:0<0,127,1>Mod 5 Start
slider9:0<0,127,1>Mod 6 Start
slider10:0<0,127,1>Mod 7 Start
slider11:0<0,127,1>Mod 8 Start
slider12:0<0,127,1>Mod 9 Start
slider13:0<0,127,1>Mod 10 Start

@init

ext_noinit = 1;

// GENERATED_CONSTANTS_START

// Ce code a été généré automatiquement par PoulpyLoopyCore0.lua
// Ne pas modifier manuellement

// Constantes de base
MODULATION_COUNT = 10;
MODULATION_SIZE = 20;
NUM_NOTES = 128;
BLOCK_SIZE = 1024;
UNIT_SIZE = 262144;

// Indices GMEM
GMEM_RECORD_MONITOR_MODE = 0;
GMEM_PLAYBACK_MODE = 1;
GMEM_STATS_BASE = 2;
GMEM_NEXT_INSTANCE_ID = 194;
GMEM_MONITORING_STOP_BASE = 195;
GMEM_NOTE_START_POS_BASE = 259;
GMEM_LOOP_LENGTH_BASE = 8451;
GMEM_FORCE_ANALYZE = 16000;
GMEM_MIDI_SYNC_DATA_BASE = 16001;
GMEM_AFFICHAGE_CONSOLE_DEBUG = 16998;
GMEM_MESSAGE_WRITE_POS = 16999;
GMEM_MESSAGE_BASE = 17000;
GMEM_MESSAGE_END = 18000;
GMEM_UI_COMMAND = 29000;
GMEM_INSTANCE_ID = 29001;
GMEM_DATA_LENGTH = 29002;
GMEM_WRITING_RIGHT = 29003;
GMEM_TOTAL_LENGTH = 29004;
GMEM_SAVE_COMPLETE = 29005;
GMEM_DEBUG_CODE = 29006;
GMEM_DEBUG_VALUE = 29007;
GMEM_LOG_START = 29008;
GMEM_LOG_LENGTH = 29009;
GMEM_LOG_DATA = 29010;
GMEM_DATA_SIZE = 29011;
GMEM_DATA_BUFFER = 30000;
GMEM_DATA_BUFFER_END = 59999;

// Types de loops
LOOP_TYPE_RECORD = 0;
LOOP_TYPE_OVERDUB = 1;
LOOP_TYPE_PLAY = 2;
LOOP_TYPE_MONITOR = 3;
LOOP_TYPE_UNUSED = 4;

// Codes de débogage
DEBUG_NONE = 0;
DEBUG_FIND_NOTE_START = 1;
DEBUG_FIND_NOTE_FOUND = 2;
DEBUG_FIND_NOTE_NONE = 3;
DEBUG_SAVE_START = 4;
DEBUG_SAVE_NO_DATA = 5;
DEBUG_SAVE_NOTE_START = 6;
DEBUG_SAVE_NOTE_DATA = 7;
DEBUG_SAVE_NOTE_END = 8;

// Version
VERSION = "0015";

// Debug
DEBUG_DEV = 0;
DEBUG_AFFICHAGE_CONSOLE = 17100;

// GENERATED_CONSTANTS_END

// Fonction pour écrire dans le journal
function write_log(msg_type, value1, value2)
(
  log_pos = gmem[GMEM_LOG_LENGTH];
  offset = GMEM_LOG_DATA + log_pos * 3;
  gmem[offset] = msg_type;
  gmem[offset + 1] = value1;
  gmem[offset + 2] = value2;
  gmem[GMEM_LOG_LENGTH] = log_pos + 1;
);

// Calculer le nombre maximum d'unités à partir de maxmem
max_units = floor(32000000 / UNIT_SIZE);  // maxmem est en octets, on divise par la taille d'une unité

// Variable pour stocker l'offset en cours pour cette instance
current_offset = 0; // Valeur en secondes
has_offset = 0;     // Flag indiquant si un offset valide est disponible

// Définition des fonctions
function get_unique_instance_id()
(
  // Lire le prochain ID disponible
  next_id = gmem[GMEM_NEXT_INSTANCE_ID];
  
  // Si c'est la première fois, initialiser à 0
  (next_id == 0) ? next_id = 0;
  
  // Incrémenter pour la prochaine instance
  gmem[GMEM_NEXT_INSTANCE_ID] = (next_id + 1) % 64;
  
  // Retourner l'ID attribué
  next_id;
);

// Attribuer un identifiant unique à cette instance
instance_id = get_unique_instance_id();  // Un identifiant entre 0 et 63

function init_modulation_values()
(
  // Initialiser toutes les valeurs à 0
  i = 0;
  loop(MODULATION_SIZE,
    modulation_values[i] = 0;
    i += 1;
  );
);

function get_modulation_start(index)
(
  (index >= 0 && index < MODULATION_COUNT) ? modulation_values[index * 2] : 0;
);

function get_modulation_end(index)
(
  (index >= 0 && index < MODULATION_COUNT) ? modulation_values[index * 2 + 1] : 0;
);

function set_modulation_start(index, value)
(
  (index >= 0 && index < MODULATION_COUNT) ? (
    modulation_values[index * 2] = value;
    1;
  ) : 0;
);

function set_modulation_end(index, value)
(
  (index >= 0 && index < MODULATION_COUNT) ? (
    modulation_values[index * 2 + 1] = value;
    1;
  ) : 0;
);

function get_record_monitor_loops_mode()
(
  gmem[GMEM_RECORD_MONITOR_MODE];
);

function get_playback_mode()
(
  gmem[GMEM_PLAYBACK_MODE];
);

function update_stats()
(
  // Base pour les statistiques de cette instance
  stats_base = GMEM_STATS_BASE + instance_id * 3;
  
  // Calculer la mémoire utilisée en Mo (8 octets par échantillon car format 64 bits)
  memory_used_mb = (next_free_unit[0] * UNIT_SIZE * 8) / (1024 * 1024);
  
  
  // Compter le nombre de notes actives (vérifier à la fois loop_type et note_length)
  notes_count = 0;
  active_instance = 0;
  i = 0;
  loop(NUM_NOTES,
    (note_length[i] > 0) ? (
      notes_count += 1;
      // Activation automatique des notes ayant du contenu
      (loop_type[i] < 0) ? loop_type[i] = 0;  // Définir comme RECORD par défaut
    );
    
    (loop_type[i] >= 0 || is_playing[i] > 0 || note_length[i] > 0) ? active_instance = 1;
    i += 1;
  );
  
  // Écrire que cette instance est active si un des tableaux est utilisé
  (next_free_unit[0] > 0 || notes_count > 0) ? active_instance = 1;
  
  // Si on a des échantillons ou des notes, indiquer que l'instance est active
  //sprintf(current_display, "écriture gmem de l'adresse %d à %d",stats_base,stats_base+2); 
  gmem[stats_base] = active_instance ? memory_used_mb : 0;
  gmem[stats_base + 1] = time_left;
  gmem[stats_base + 2] = notes_count;
);

function cc7ToGain(ccVal)
(
  dB = (ccVal - 64) * (20.0/64.0);
  10^(dB/20.0);
);

function cc10ToPan(ccVal)
(
  ccVal / 127.0;
);

function getNoteIndex(note)
(
  (note >= 0 && note < 128) ? note : -1;
);

function startRecording(note, mode)
(
  // En mode PLAYBACK, on n'enregistre pas
  (get_playback_mode() == 1) ? (
    sprintf(current_display, "Mode PLAYBACK: enregistrement désactivé");
    0; // Ne rien faire
  ) : (
    note_length[note] = 0;
    units_count[note] = 1;
    is_recording[note] = 1;
    is_playing[note] = 0;
    read_pos[note] = 0;
    rec_mode[note] = mode;
    nu = next_free_unit[0];
    (nu >= max_units) ? (
      is_recording[note] = 0;
      note_start[note] = 0;
      strcpy(current_display, "Memo saturée: impossible rec");
    ) : (
      note_start[note] = nu * UNIT_SIZE;
      next_free_unit[0] = nu + 1;
    );
  );
);

function expandRecording(note)
(
  // En mode PLAYBACK, on n'étend pas l'enregistrement
  (get_playback_mode() == 1) ? (
    0; // Ne rien faire
  ) : (
    nu = next_free_unit[0];
    curUnits = units_count[note];
    (nu < max_units) ? (
      units_count[note] = curUnits + 1;
      next_free_unit[0] = nu + 1;
    ) : (
      is_recording[note] = 0;
      strcpy(current_display, "Memo full en cours d'enregistrement");
    );
  );
);

// Variables pour la sauvegarde/chargement
save_state = 0;              // 0=idle, 1=en cours de sauvegarde/chargement
save_current_position = 0;   // Position actuelle dans les données
memory_size = 0;            // Taille totale de la mémoire utilisée

// Initialisation des variables
instance_memory =0; // représentation de la mémoire dans son ensemble pour opérations de sauvegarde et chargement
time_left_str = 100;
current_display= 200;
note_start    = 300;
note_length   = note_start    + NUM_NOTES;
units_count   = note_length   + NUM_NOTES;
is_playing    = units_count   + NUM_NOTES;
is_recording  = is_playing    + NUM_NOTES;
read_pos      = is_recording  + NUM_NOTES;
rec_mode      = read_pos      + NUM_NOTES;
next_free_unit = rec_mode     + NUM_NOTES;
modulation_values = next_free_unit + NUM_NOTES;
the_memory    = modulation_values + MODULATION_SIZE;

// Variable unique pour la longueur temporaire
temp_block_length = 0;

// Initialisation des tableaux
i = 0;
loop(NUM_NOTES,
  note_start[i] = 0;
  note_length[i] = 0;
  units_count[i] = 0;
  is_playing[i] = 0;
  is_recording[i] = 0;
  read_pos[i] = 0;
  rec_mode[i] = 0;
  block_length[i] = 0; // Initialisation de block_length
  i += 1;
);
next_free_unit[0] = 0;

i = 0;
loop(NUM_NOTES,
  loop_type[i] = -1;
  i += 1;
);

//strcpy(current_display, "Sampler init OK");
strcpy(time_left_str, "Loading...");

volumeFactor = 1.0;
panFactor    = 0.5;
mode = 0;
monitoring = 0; // Par défaut, le monitoring est désactivé (OFF)


// Variables pour la synchronisation des offsets
using_offsets = 0;
offset_position = 0;
measure_duration = 0;
// play_state = 0; // désactivée car read only
track_id_found = -1;

// Variables pour la sauvegarde/chargement des données
save_state = 0;              // 0=idle, 1=envoi taille totale, 2=envoi données
save_current_position = 0;   // Position actuelle dans les données à sauvegarder
save_total_size = 0;        // Taille totale des données à sauvegarder
save_active_note = -1;      // Note active en cours de sauvegarde
save_notes_queue = 0;       // File d'attente des notes à sauvegarder
save_note_length = 0;       // Longueur de la note en cours de sauvegarde

@slider
fade_samples = slider1;
// Mettre à jour gmem avec l'état du monitoring à l'arrêt
//gmem[GMEM_MONITORING_STOP_BASE + instance_id] = slider3;

@block


// Synchroniser le slider avec gmem
// TODO : vérifier qu'on recopie bien cette valeur dans monitoring
slider3 = gmem[GMEM_MONITORING_STOP_BASE + instance_id];

// Traitement des commandes provenant de PoulpyLoopyUI
command = gmem[GMEM_UI_COMMAND];
target_instance = gmem[GMEM_INSTANCE_ID];

// Vérifier si on a une commande de sauvegarde et si elle est destinée à cette instance
(command == 1 && target_instance == instance_id && gmem[GMEM_WRITING_RIGHT] == 1) ? (
    // Si on n'a pas encore commencé la sauvegarde
    (save_state == 0) ? (
        // Calculer la taille totale de la mémoire utilisée
        memory_size = the_memory + (next_free_unit[0] * UNIT_SIZE);
        
        // Écrire la taille dans gmem
        gmem[GMEM_DATA_SIZE] = memory_size;
        
        // Debug: afficher les informations de mémoire
        sprintf(current_display, "Save: mem_size=%d the_mem=%d next=%d unit=%d gmem_size=%d", 
          memory_size, the_memory, next_free_unit[0], UNIT_SIZE, gmem[GMEM_DATA_SIZE]);
        
        // Initialiser les variables de sauvegarde
        save_current_position = 0;
        save_state = 1; 

        
        // Rendre le contrôle à l'UI
        gmem[GMEM_WRITING_RIGHT] = 0;
    ) : (save_state == 1) ? (
        // Si on a encore des données à envoyer
        (save_current_position < memory_size) ? (
            // Calculer la taille du prochain bloc
            block_size = min(30000, memory_size - save_current_position);
            
            // Copier le bloc dans gmem
            
              i = 0;
              while (i < block_size) (
                gmem[GMEM_DATA_BUFFER + i] = instance_memory[save_current_position + i];
                i += 1;
                );
            
            // Mettre à jour la position
            save_current_position += block_size;
            
            // Si on a fini, réinitialiser l'état
            (save_current_position >= memory_size) ? (
                //save_state = 0;
                //save_current_position = 0;
                // Signaler que la sauvegarde est terminée
                gmem[GMEM_SAVE_COMPLETE] = 1;
            );
            
            // Rendre le contrôle à l'UI
            gmem[GMEM_WRITING_RIGHT] = 0;
        ) : (
            // Si on n'a plus de données à envoyer, réinitialiser l'état
            save_state = 0;
            save_current_position = 0;
            gmem[GMEM_WRITING_RIGHT] = 0;
        );
    );
) : (command == 2 && target_instance == instance_id && gmem[GMEM_WRITING_RIGHT] == 1) ? (
    // Si on n'a pas encore commencé le chargement
    (save_state == 0) ? (
        // Lire la taille totale de la mémoire
        memory_size = gmem[GMEM_DATA_SIZE];
        
        // Debug: afficher les informations de chargement
        sprintf(current_display, "Load: mem_size=%d the_mem=%d next=%d unit=%d gmem_size=%d", 
          memory_size, the_memory, next_free_unit[0], UNIT_SIZE, gmem[GMEM_DATA_SIZE]);
        
        // Initialiser les variables de chargement
        save_current_position = 0;
        save_state = 1;
        
        // Rendre le contrôle à l'UI
        gmem[GMEM_WRITING_RIGHT] = 0;
    ) : (save_state == 1) ? (
        // Si on a encore des données à charger
        (save_current_position < memory_size) ? (
            // Calculer la taille du prochain bloc
            block_size = min(30000, memory_size - save_current_position);
            
            // Debug: afficher la progression du chargement
            sprintf(current_display, "Loading: pos=%d/%d block=%d", 
              save_current_position, memory_size, block_size);
            
            // Copier le bloc depuis gmem
            i = 0;
            while (i < block_size) (
                the_memory[save_current_position + i] = gmem[GMEM_DATA_BUFFER + i];
                i += 1;
            );
            
            // Mettre à jour la position
            save_current_position += block_size;
            
            // Si on a fini, réinitialiser l'état
            (save_current_position >= memory_size) ? (
                save_state = 0;
                save_current_position = 0;
                // Mettre à jour next_free_unit en divisant par UNIT_SIZE
                next_free_unit[0] = ceil(memory_size / UNIT_SIZE);
                
                // Debug: afficher les informations finales
                sprintf(current_display, "Loaded: total=%d units=%d", 
                  memory_size, next_free_unit[0]);
            );
            
            // Rendre le contrôle à l'UI
            gmem[GMEM_WRITING_RIGHT] = 0;
        ) : (
            // Si on n'a plus de données à charger, réinitialiser l'état
            save_state = 0;
            save_current_position = 0;
            gmem[GMEM_WRITING_RIGHT] = 0;
        );
    );
);

// Mise à jour des sliders de modulation
i = 0;
loop(NUM_NOTES,
  (loop_type[i] >= 0) ? (
    // Calculer le pourcentage de progression dans la loop
    progress = 0;
    
    // Utiliser temp_block_length pour RECORD et MONITOR
    ((is_recording[i] || loop_type[i] == 3) && temp_block_length > 0) ? (
      progress = (read_pos[i] / srate * 10) / temp_block_length;
      progress = min(progress, 1); // S'assurer que progress ne dépasse pas 1
    ) : (
      // Pour les autres blocs, utiliser note_length
      (note_length[i] > 0) ? (
        progress = read_pos[i] / note_length[i];
      );
    );
    
    // Si on a une progression valide, mettre à jour les sliders
    (progress > 0) ? (
      j = 0;
      loop(MODULATION_COUNT,
        start_val = get_modulation_start(j);
        end_val = get_modulation_end(j);
        
        // Interpolation linéaire
        current_val = start_val + (end_val - start_val) * progress;
        
        // Mise à jour du slider correspondant
        slider(j + 4) = current_val;
        
        j += 1;
      );
    );
  );
  i += 1;
);

// Obtenir la position de lecture actuelle
play_position = play_position_samples / srate;

// Détection simple de l'état de lecture
prev_play_state = play_state;
//play_state = (play_state > 0) ? 1 : 0;

// Lire l'offset pour cette instance depuis la mémoire partagée
sync_base = GMEM_MIDI_SYNC_DATA_BASE + instance_id * 3;
track_id = gmem[sync_base];
offset_position = gmem[sync_base + 1];
measure_duration = gmem[sync_base + 2];

// Mettre à jour la variable using_offsets pour l'affichage dans l'interface
using_offsets = (offset_position > 0 && measure_duration > 0) ? 1 : 0;

// Variable pour suivre si des notes ont été traitées dans ce bloc
midi_notes_processed = 0;

while (
  midirecv(offset, msg1, msg2, msg3) ? (
    status = msg1 & $xF0;
    note   = msg2;
    vel    = msg3;
    idx    = getNoteIndex(note);
    
    // Augmenter le compteur de notes MIDI traitées
    (status == $x90 && vel > 0) ? (
      midi_notes_processed += 1;
    );

    (status == $xB0) ? (
      ((idx >= 0)&& play_state) ? (
        (msg2 == 7) ? (
            volumeFactor = cc7ToGain(msg3);
        ) : (msg2 == 9) ? (
            slider2 = msg3 - 64;
        ) : (msg2 == 10) ? (
            panFactor = cc10ToPan(msg3);
        ) : (msg2 == 8) ?(
            mode = msg3;
        ) : (msg2 == 11) ? (
            monitoring = msg3 > 0 ? 1 : 0;
            //sprintf(current_display, "midi message, monitoring : %d", monitoring)
        ) : (msg2 == 19) ? (
            temp_block_length = msg3 * 128;
        ) : (msg2 == 20) ? (
            temp_block_length += msg3;
        ) : (msg2 >= 21 && msg2 <= 40) ? (
            // Traitement des CC 21-40 pour les valeurs de modulation
            mod_index = floor((msg2 - 21) / 2);
            is_end = (msg2 - 21) % 2;
            (is_end == 0) ? (
                set_modulation_start(mod_index, msg3);              
            ) : (
                set_modulation_end(mod_index, msg3);
            );
        );
      );
    );

    (status == $x90 && vel > 0) ? (  // Note ON
      (idx >= 0) ? (
        // Pour les blocs RECORD ou MONITOR, afficher la longueur attendue
        ((vel == 1 || vel == 4) && temp_block_length > 0) ? (
          temp_block_length = temp_block_length;
          //sprintf(current_display, "Longueur attendue: %.1f dixièmes de seconde", temp_block_length);
        );

        // Stocker la position de début de la note dans gmem
        note_pos_index = GMEM_NOTE_START_POS_BASE + instance_id * 128 + idx;
        sprintf(current_display, "écriture gmem de l'adresse %d à %d",note_pos_index,note_pos_index); 
        gmem[note_pos_index] = play_position + offset / srate;
        
        // Afficher les valeurs de modulation pour cette note
        i = 0;
        loop(MODULATION_COUNT,
          start_val = get_modulation_start(i);
          end_val = get_modulation_end(i);
          
          // Mettre à jour les sliders avec les valeurs de début
          slider(i + 4) = start_val;
          
          i += 1;
        );
        
        // Stocker la longueur de la boucle en secondes si elle existe
        loop_len_index = GMEM_LOOP_LENGTH_BASE + instance_id * 128 + idx;
        (note_length[idx] > 0) ? (
          gmem[loop_len_index] = note_length[idx] / srate;
        ) : (
          gmem[loop_len_index] = -1;
        );
        
        // Vérifier si on est en mode PLAYBACK
        playback_mode = get_playback_mode();
        
        (vel == 1) ? ( // RECORD
          (playback_mode == 1) ? (
            // En mode PLAYBACK, on lit la loop RECORD si elle existe
            (note_length[idx] > 0) ? (
              is_playing[idx] = 1;
              read_pos[idx] = 0;
              is_recording[idx] = 0;
              loop_type[idx] = 0; // Garder le type RECORD
              sprintf(current_display, "Playback: lecture RECORD note=%d", note);
            ) : (
              sprintf(current_display, "Playback: pas de contenu pour RECORD note=%d", note);
            );
          ) : (
            // En mode LIVE, comportement normal
            startRecording(idx, mode);
            loop_type[idx] = 0;
            //sprintf(current_display, "Rec note=%d vel=%d mode=%s", note, vel, mode ? "Stereo" : "Mono");
          );
        )
        : (vel == 2) ? ( // PLAY
          (note_length[idx] > 0) ? (
            is_playing[idx] = 1;
            read_pos[idx] = 0;
            //sprintf(current_display, "PLAY: note=%d pos=0/%d", note, note_length[idx]);
            is_recording[idx] = 0;
            loop_type[idx] = 1;
          ) : sprintf(current_display, "Pas de sample pour %d", note);
        )
        : (vel == 3) ? ( // OVERDUB
          (playback_mode == 1) ? (
            (note_length[idx] > 0) ? (
              is_playing[idx] = 1;
              read_pos[idx] = 0;
              sprintf(current_display, "OVERDUB: note=%d pos=0/%d", note, note_length[idx]);
              is_recording[idx] = playback_mode == 0;
              loop_type[idx] = 2;
            ) : (
              sprintf(current_display, "Playback: pas de contenu pour OVERDUB note=%d", note);
            );
          ) : (
            // En mode LIVE, comportement normal
            (note_length[idx] == 0) ? (
              startRecording(idx, mode);
            ) : (
              is_recording[idx] = 1;
              read_pos[idx] = 0;
            );
            loop_type[idx] = 2;
            is_playing[idx] = 1;
            sprintf(current_display, "Overdub note=%d vel=%d mode=%s", note, vel, mode ? "Stereo" : "Mono");
          );
        )
        : (vel == 4) ? ( // MONITOR
          (playback_mode == 1) ? (
            (note_length[idx] > 0) ? (
              is_playing[idx] = 1;
              read_pos[idx] = 0;
              is_recording[idx] = 0;
              loop_type[idx] = 3;
              sprintf(current_display, "MONITOR: playback mode");
            );
          ) : (
            is_playing[idx] = 1;
            loop_type[idx] = 3;
            sprintf(current_display, "MONITOR: live mode, type=%d", loop_type[idx]);
            
            record_monitor_mode = get_record_monitor_loops_mode();
            (record_monitor_mode == 1) ? (
              startRecording(idx, mode);
            );
          );
        )
        : sprintf(current_display, "Vel. non supportée: %d", vel)
      );
    );

    (status == $x80 || (status == $x90 && vel == 0)) ? ( // NOTE OFF
      (idx >= 0) ? (
        // Réinitialiser la position de début de la note
        note_pos_index = GMEM_NOTE_START_POS_BASE + instance_id * 128 + idx;
        gmem[note_pos_index] = -1;
        
        // Réinitialiser l'offset pour cette instance
        sync_base = GMEM_MIDI_SYNC_DATA_BASE + instance_id * 3;
        gmem[sync_base + 1] = 0;  // Offset = 0
        
        is_playing[idx] = 0;
        is_recording[idx] = 0;
        loop_type[idx] = -1;
        // Remettre le pitch à sa valeur par défaut quand aucune boucle n'est active
        any_playing = 0;
        i = 0;
        loop(NUM_NOTES,
          any_playing += (loop_type[i] == 1);
          i += 1;
        );
        (any_playing == 0) ? (
          // Envoyer CC09 = 64 pour un pitch de 0
          midisend(offset, $xB0, 9, 64);
        );
        //strcpy(current_display, "Note off");
        monitoring = 0;
      );
    );
    offset += 1;
  );
);

units_used = next_free_unit[0];
units_left = max_units - units_used;
samples_left = units_left * UNIT_SIZE;
time_left = samples_left / srate;
sprintf(time_left_str, "Memo left: %.1f s", time_left);

// Mettre à jour les statistiques dans gmem
update_stats();



@sample
inL = spl0;
inR = spl1;

recL = 0;
recR = 0;
playL = 0;
playR = 0;
monL = 0;
monR = 0;

// Calcul des gains pour le pan sinusoïdal
gainL = cos($pi * 0.5 * panFactor) * sqrt(2);
gainR = sin($pi * 0.5 * panFactor) * sqrt(2);

// Variable pour détecter si au moins une boucle est active
any_loop_active = 0;

// Vérifier si on est en mode PLAYBACK
playback_mode = get_playback_mode();

i = 0;
loop(NUM_NOTES,
  (loop_type[i] != -1) ? (  // Boucle active
    any_loop_active = 1;
    curLen = note_length[i];
    unitCount = units_count[i];
    capacity = unitCount * UNIT_SIZE;
    
    // Incrémenter read_pos pour la lecture, l'enregistrement et les blocs MONITOR
    ((is_playing[i] || is_recording[i] || loop_type[i] == 3) && (curLen > 0 || is_recording[i] || loop_type[i] == 3)) ? (
      read_pos[i] += 1;
      // Pour les blocs MONITOR, on boucle sur temp_block_length
      (loop_type[i] == 3 && temp_block_length > 0) ? (
        (read_pos[i] >= temp_block_length * srate / 10) ? read_pos[i] = 0;
      ) : (
        // Pour les autres blocs, on boucle sur note_length
        (read_pos[i] >= curLen && !is_recording[i]) ? read_pos[i] = 0;
      );
      pos = read_pos[i];
      
      // Calculer la position de lecture effective avec l'offset
      effective_pos = offset_position > 0 ? 
        floor((pos + floor(offset_position * srate)) % curLen) : 
        pos;
    ) : (
      // Si pas en lecture/enregistrement, maintenir la position actuelle
      pos = read_pos[i];
      effective_pos = pos;
    );
    
    // Lire le contenu actuel si en lecture ou en mode particulier
    ((is_playing[i] && curLen > 0) || playback_mode == 1) ? (
      // Calcul des enveloppes de fade
      fade_gain = 1.0;
      (fade_samples > 0) ? (
        (effective_pos < fade_samples) ? (
          fade_gain = effective_pos / fade_samples;
        ) : (effective_pos >= curLen - fade_samples) ? (
          fade_gain = (curLen - effective_pos) / fade_samples;
        );
      );
      
      (rec_mode[i] == 0) ? ( // MONO
        sampleMono = the_memory[note_start[i] + effective_pos];
        playL += sampleMono * volumeFactor * gainL * fade_gain;
        playR += sampleMono * volumeFactor * gainR * fade_gain;
      ) : ( // STEREO
        baseOfs = note_start[i] + 2*effective_pos;
        sampleL = the_memory[baseOfs];
        sampleR = the_memory[baseOfs+1];
        playL += sampleL * volumeFactor * gainL * fade_gain;
        playR += sampleR * volumeFactor * gainR * fade_gain;
      );
    );

    // Gérer l'enregistrement après la lecture (uniquement en mode LIVE)
    (play_state && playback_mode == 0 && (loop_type[i] == 0 || loop_type[i] == 2 || (loop_type[i] == 3 && get_record_monitor_loops_mode() == 1))) ? (
      // Appliquer volume/pan/mode *COURANTS* avant l'enregistrement
      (mode == 0) ? ( // Mono
        recL = inL * volumeFactor * gainL;
        recR = inL * volumeFactor * gainR;  // Même signal en mono
      ) : ( // Stereo
        recL = inL * volumeFactor * gainL;
        recR = inR * volumeFactor * gainR;
      );

      // Position d'écriture - pour OVERDUB, utiliser le même loopPos que pour la lecture
      writePos = (loop_type[i] == 2) ? (pos % curLen) : curLen;
      
      (loop_type[i] == 0 || loop_type[i] == 3) ? (  // RECORD ou MONITOR avec enregistrement
        (rec_mode[i] == 0) ? ( // Mono
          the_memory[note_start[i] + writePos] = recL;
        ) : ( // Stereo
          the_memory[note_start[i] + 2*writePos] = recL;
          the_memory[note_start[i] + 2*writePos+1] = recR;
        );
        
        // Incrémenter la longueur uniquement pour RECORD ou MONITOR avec enregistrement
        note_length[i] = curLen + 1;
        (curLen + 1 >= capacity) ? (
          expandRecording(i);
          // Debug: afficher les informations de mémoire
          sprintf(current_display, "Mem: note=%d start=%d len=%d units=%d next=%d", 
            i, note_start[i], note_length[i], units_count[i], next_free_unit[0]);
        );
        
      ) : (  // OVERDUB - ici on ADDITIONNE au lieu de remplacer
        (curLen > 0) ? (  // Seulement si on a déjà du contenu
          (rec_mode[i] == 0) ? ( // Mono
            the_memory[note_start[i] + writePos] += recL;
          ) : ( // Stereo
            the_memory[note_start[i] + 2*writePos] += recL;
            the_memory[note_start[i] + 2*writePos+1] += recR;
          );
        ) : (
          // Si longueur=0 en OVERDUB, traiter comme RECORD
          (rec_mode[i] == 0) ? ( // Mono
            the_memory[note_start[i] + writePos] = recL;
          ) : ( // Stereo
            the_memory[note_start[i] + 2*writePos] = recL;
            the_memory[note_start[i] + 2*writePos+1] = recR;
          );
          // Incrémenter la longueur
          note_length[i] = curLen + 1;
          (curLen + 1 >= capacity) ? (expandRecording(i));
        );
      );
    );
  );
  i += 1;
);

// Monitoring avec pan sinusoïdal (uniquement si une boucle est active, qu'on n'est pas en mode PLAYBACK
// ET que la lecture est active OU que le monitoring à l'arrêt n'est pas activé)
(monitoring && any_loop_active && (playback_mode == 0) && (play_state || !slider3)) ? (
  //sprintf(current_display, "monitoring pan sinusoidal");
  (mode == 0) ? ( // Mono 
    monL = inL * volumeFactor * gainL;
    monR = inL * volumeFactor * gainR;  // Même signal en mono
  ) : ( // Stereo
    monL = inL * volumeFactor * gainL;
    monR = inR * volumeFactor * gainR;
  );
) : (//sprintf(current_display, "stop monitoring pan sinusoidal"); 
dummy = 1;
);

// Complètement réorganiser la logique de sortie pour éviter les additifs
(!play_state && slider3) ? (
  // Monitoring à l'arrêt est prioritaire quand lecture arrêtée - signal DIRECT sans traitement
  spl0 = inL;
  spl1 = inR;
) : (
  // Lecture normale, uniquement le contenu joué + monitoring normal
  spl0 = playL;
  spl1 = playR;
  
  // Ajouter le monitoring UNIQUEMENT si on n'est pas en mode monitoring à l'arrêt
  (!(!play_state && slider3)) ? (
    spl0 += monL;
    spl1 += monR;
  );
);

@gfx
gfx_clear = 0;
gfx_setfont(1, "Arial", 30);
gfx_set(1,1,1,1);

// Afficher l'état de lecture en haut
gfx_x = 10;
gfx_y = 10;
gfx_set(1, 1, 1, 1);
gfx_drawstr("État de lecture: ");
gfx_x += 200;
(play_state >= 1) ? (
  gfx_set(0.5, 1, 0.5, 1); // Vert pour LECTURE
  gfx_drawstr("LECTURE");
) : (
  gfx_set(1, 0.5, 0.5, 1); // Rouge pour ARRÊTÉ
  gfx_drawstr("ARRÊTÉ");
);

// Afficher le mode actuel
playback_mode = get_playback_mode();
gfx_x = 10;
gfx_y = 50;
gfx_set(0.5, 1, 0.5, 1); // Vert pour LIVE
gfx_drawstr("Mode: LIVE");

// Afficher le temps restant
gfx_x = 10;
gfx_y = 90;
gfx_drawstr(time_left_str);

// Afficher le message courant
gfx_x = 10;
gfx_y = 130;
gfx_drawstr(current_display);
